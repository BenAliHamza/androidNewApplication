===== FILE: ./app/src/main/java/tn/esprit/presentation/home/PatientHomeViewModel.java =====
package tn.esprit.presentation.home;

import android.app.Application;

import androidx.annotation.NonNull;
import androidx.lifecycle.AndroidViewModel;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import java.util.ArrayList;
import java.util.List;

import tn.esprit.data.doctor.DoctorDirectoryRepository;
import tn.esprit.domain.doctor.DoctorSearchFilters;
import tn.esprit.domain.doctor.DoctorSearchResult;

public class PatientHomeViewModel extends AndroidViewModel {

    private static final int MAX_RESULTS = 5;

    private final DoctorDirectoryRepository doctorDirectoryRepository;

    private final MutableLiveData<String> query = new MutableLiveData<>("");
    private final MutableLiveData<List<DoctorSearchResult>> results = new MutableLiveData<>(new ArrayList<>());
    private final MutableLiveData<Boolean> loading = new MutableLiveData<>(false);
    private final MutableLiveData<String> errorMessage = new MutableLiveData<>(null);
    private final MutableLiveData<Boolean> hasSearched = new MutableLiveData<>(false);

    public PatientHomeViewModel(@NonNull Application application) {
        super(application);
        doctorDirectoryRepository = new DoctorDirectoryRepository(application.getApplicationContext());
    }

    public LiveData<String> getQuery() {
        return query;
    }

    public LiveData<List<DoctorSearchResult>> getResults() {
        return results;
    }

    public LiveData<Boolean> getLoading() {
        return loading;
    }

    public LiveData<String> getErrorMessage() {
        return errorMessage;
    }

    /**
     * Indicates whether user has actually triggered a search at least once.
     * Used to distinguish "idle" vs "no results" states in UI.
     */
    public LiveData<Boolean> getHasSearched() {
        return hasSearched;
    }

    /**
     * Called when the search text changes and user stops typing (debounced in Fragment).
     */
    public void searchDoctors(String rawQuery) {
        String trimmed = rawQuery != null ? rawQuery.trim() : "";
        query.setValue(trimmed);

        // If query is too short, reset to idle state.
        if (trimmed.length() < 2) {
            loading.setValue(false);
            errorMessage.setValue(null);
            results.setValue(new ArrayList<>());
            hasSearched.setValue(false);
            return;
        }

        loading.setValue(true);
        errorMessage.setValue(null);

        DoctorSearchFilters filters = DoctorSearchFilters.fromQuery(trimmed);

        doctorDirectoryRepository.searchDoctors(filters, new DoctorDirectoryRepository.SearchCallback() {
            @Override
            public void onSuccess(List<DoctorSearchResult> searchResults) {
                loading.postValue(false);
                hasSearched.postValue(true);

                if (searchResults == null) {
                    results.postValue(new ArrayList<>());
                    return;
                }

                // Limit to MAX_RESULTS for this quick search UI
                List<DoctorSearchResult> limited;
                if (searchResults.size() > MAX_RESULTS) {
                    limited = new ArrayList<>(searchResults.subList(0, MAX_RESULTS));
                } else {
                    limited = new ArrayList<>(searchResults);
                }

                results.postValue(limited);
            }

            @Override
            public void onError(Throwable throwable, Integer httpCode, String errorBody) {
                loading.postValue(false);
                hasSearched.postValue(true);

                String msg = null;
                if (throwable != null) {
                    msg = "Network error while searching for doctors.";
                } else if (httpCode != null) {
                    msg = "Search failed with code " + httpCode;
                }

                if (errorBody != null && !errorBody.isEmpty()) {
                    if (msg == null) {
                        msg = errorBody;
                    } else {
                        msg = msg + " " + errorBody;
                    }
                }

                errorMessage.postValue(msg);
            }
        });
    }

    /**
     * Explicitly clears the search field and results.
     */
    public void clearSearch() {
        query.setValue("");
        results.setValue(new ArrayList<>());
        loading.setValue(false);
        errorMessage.setValue(null);
        hasSearched.setValue(false);
    }
}


===== FILE: ./app/src/main/java/tn/esprit/presentation/home/PatientHomeFragment.java =====
package tn.esprit.presentation.home;

import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.google.android.material.textfield.TextInputEditText;

import java.util.List;

import tn.esprit.R;
import tn.esprit.domain.doctor.DoctorSearchResult;

public class PatientHomeFragment extends Fragment implements DoctorSearchResultAdapter.OnDoctorClickListener {

    private static final long SEARCH_DEBOUNCE_MS = 350L;

    private PatientHomeViewModel viewModel;

    private TextInputEditText inputSearch;
    private RecyclerView recyclerResults;
    private ProgressBar progressBar;
    private TextView textEmpty;

    private DoctorSearchResultAdapter adapter;

    private final Handler handler = new Handler(Looper.getMainLooper());
    private Runnable pendingSearchRunnable;

    public PatientHomeFragment() {
        // Required empty constructor
    }

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater,
                             @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_home_patient, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view,
                              @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        inputSearch = view.findViewById(R.id.input_search_doctors);
        recyclerResults = view.findViewById(R.id.recycler_doctor_results);
        progressBar = view.findViewById(R.id.patient_home_progress);
        textEmpty = view.findViewById(R.id.text_patient_home_empty);

        adapter = new DoctorSearchResultAdapter(this);
        if (recyclerResults != null) {
            recyclerResults.setLayoutManager(new LinearLayoutManager(requireContext()));
            recyclerResults.setAdapter(adapter);
        }

        viewModel = new ViewModelProvider(this).get(PatientHomeViewModel.class);

        setupObservers();
        setupSearchInput();
    }

    private void setupObservers() {
        viewModel.getResults().observe(getViewLifecycleOwner(), this::bindResults);
        viewModel.getLoading().observe(getViewLifecycleOwner(), this::bindLoading);
        viewModel.getErrorMessage().observe(getViewLifecycleOwner(), this::bindError);
        viewModel.getHasSearched().observe(getViewLifecycleOwner(), hasSearched -> {
            // Update empty state when hasSearched toggles
            List<DoctorSearchResult> current = viewModel.getResults().getValue();
            bindEmptyState(current, hasSearched != null && hasSearched);
        });
    }

    private void setupSearchInput() {
        if (inputSearch == null) return;

        inputSearch.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s,
                                          int start,
                                          int count,
                                          int after) {
                // no-op
            }

            @Override
            public void onTextChanged(CharSequence s,
                                      int start,
                                      int before,
                                      int count) {
                // Debounce typing
                if (pendingSearchRunnable != null) {
                    handler.removeCallbacks(pendingSearchRunnable);
                }

                final String query = s != null ? s.toString() : "";
                pendingSearchRunnable = () -> viewModel.searchDoctors(query);
                handler.postDelayed(pendingSearchRunnable, SEARCH_DEBOUNCE_MS);
            }

            @Override
            public void afterTextChanged(Editable s) {
                // no-op
            }
        });
    }

    private void bindResults(@Nullable List<DoctorSearchResult> list) {
        if (list == null) {
            adapter.submitList(null);
            bindEmptyState(null, Boolean.TRUE.equals(viewModel.getHasSearched().getValue()));
            return;
        }
        adapter.submitList(list);
        bindEmptyState(list, Boolean.TRUE.equals(viewModel.getHasSearched().getValue()));
    }

    private void bindLoading(Boolean isLoading) {
        if (progressBar != null) {
            progressBar.setVisibility(Boolean.TRUE.equals(isLoading) ? View.VISIBLE : View.GONE);
        }
    }

    private void bindError(@Nullable String error) {
        if (error == null || error.trim().isEmpty()) {
            return;
        }
        if (!isAdded()) return;
        Toast.makeText(requireContext(), error, Toast.LENGTH_SHORT).show();
    }

    private void bindEmptyState(@Nullable List<DoctorSearchResult> list,
                                boolean hasSearched) {
        if (textEmpty == null) return;

        String currentQuery = viewModel.getQuery().getValue();
        String trimmed = currentQuery != null ? currentQuery.trim() : "";

        boolean hasResults = list != null && !list.isEmpty();

        if (trimmed.length() < 2) {
            // Idle state: encourage user to start typing
            textEmpty.setText(R.string.home_patient_search_empty_idle);
            textEmpty.setVisibility(View.VISIBLE);
        } else if (!hasResults && hasSearched) {
            // User searched and got no results
            textEmpty.setText(R.string.home_patient_search_empty_results);
            textEmpty.setVisibility(View.VISIBLE);
        } else {
            textEmpty.setVisibility(View.GONE);
        }
    }

    @Override
    public void onDoctorClicked(@NonNull DoctorSearchResult doctor) {
        if (!isAdded()) return;

        // Navigation to a dedicated DoctorPublicProfileFragment will be wired
        // in a later batch to avoid referencing non-existing destinations.
        // For now, we just confirm the click.
        String name = doctor.getDisplayNameCompact();
        if (name == null || name.isEmpty()) {
            name = getString(R.string.profile_role_doctor);
        }
        Toast.makeText(
                requireContext(),
                getString(R.string.home_patient_doctor_click_toast, name),
                Toast.LENGTH_SHORT
        ).show();
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        if (pendingSearchRunnable != null) {
            handler.removeCallbacks(pendingSearchRunnable);
        }
    }
}


===== FILE: ./app/src/main/java/tn/esprit/presentation/home/HomeUiHelper.java =====
package tn.esprit.presentation.home;

import java.util.Calendar;

import tn.esprit.R;

/**
 * Small UI helper for home header: greeting and role labels.
 */
public final class HomeUiHelper {

    private HomeUiHelper() {
        // no instances
    }

    /**
     * Returns the greeting string resource id based on current hour.
     */
    public static int resolveGreetingResId() {
        Calendar calendar = Calendar.getInstance();
        int hour = calendar.get(Calendar.HOUR_OF_DAY);

        if (hour < 12) {
            return R.string.home_greeting_morning;
        } else if (hour < 18) {
            return R.string.home_greeting_afternoon;
        } else {
            return R.string.home_greeting_evening;
        }
    }

    /**
     * Returns the correct role label resource id for a given backend role string.
     */
    public static int resolveRoleLabelResId(String role) {
        if (role == null) {
            return R.string.profile_role_unknown;
        }

        if ("DOCTOR".equalsIgnoreCase(role)) {
            return R.string.profile_role_doctor;
        } else if ("PATIENT".equalsIgnoreCase(role)) {
            return R.string.profile_role_patient;
        } else if ("ADMIN".equalsIgnoreCase(role)) {
            return R.string.profile_role_admin;
        } else {
            return R.string.profile_role_unknown;
        }
    }
}


===== FILE: ./app/src/main/java/tn/esprit/presentation/home/HomeFragment.java =====
package tn.esprit.presentation.home;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.view.ViewCompat;
import androidx.fragment.app.Fragment;

import tn.esprit.R;

public class HomeFragment extends Fragment {

    private View cardHighlight;
    private TextView textHighlightTitle;
    private TextView textHighlightSubtitle;

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater,
                             @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_home, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view,
                              @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        cardHighlight = view.findViewById(R.id.card_highlight);
        textHighlightTitle = view.findViewById(R.id.text_highlight_title);
        textHighlightSubtitle = view.findViewById(R.id.text_highlight_subtitle);

        // Generic highlight text (we can make this role-specific later if needed)
        textHighlightTitle.setText(getString(R.string.home_highlight_title));
        textHighlightSubtitle.setText(getString(R.string.home_highlight_subtitle));

        // Simple entrance animation
        if (cardHighlight != null) {
            cardHighlight.setAlpha(0f);
            cardHighlight.setTranslationY(24f);
            ViewCompat.animate(cardHighlight)
                    .alpha(1f)
                    .translationY(0f)
                    .setDuration(400L)
                    .setStartDelay(80L)
                    .start();
        }
    }
}


===== FILE: ./app/src/main/java/tn/esprit/presentation/home/DoctorSearchResultAdapter.java =====
package tn.esprit.presentation.home;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.DiffUtil;
import androidx.recyclerview.widget.ListAdapter;
import androidx.recyclerview.widget.RecyclerView;

import tn.esprit.R;
import tn.esprit.domain.doctor.DoctorSearchResult;

public class DoctorSearchResultAdapter
        extends ListAdapter<DoctorSearchResult, DoctorSearchResultAdapter.DoctorViewHolder> {

    public interface OnDoctorClickListener {
        void onDoctorClicked(@NonNull DoctorSearchResult doctor);
    }

    private final OnDoctorClickListener clickListener;

    public DoctorSearchResultAdapter(@NonNull OnDoctorClickListener clickListener) {
        super(DIFF_CALLBACK);
        this.clickListener = clickListener;
    }

    private static final DiffUtil.ItemCallback<DoctorSearchResult> DIFF_CALLBACK =
            new DiffUtil.ItemCallback<DoctorSearchResult>() {
                @Override
                public boolean areItemsTheSame(@NonNull DoctorSearchResult oldItem,
                                               @NonNull DoctorSearchResult newItem) {
                    if (oldItem.getDoctorId() == null || newItem.getDoctorId() == null) {
                        return oldItem == newItem;
                    }
                    return oldItem.getDoctorId().equals(newItem.getDoctorId());
                }

                @Override
                public boolean areContentsTheSame(@NonNull DoctorSearchResult oldItem,
                                                  @NonNull DoctorSearchResult newItem) {
                    // For now, treat all fields as relevant; if doctorId same and
                    // compact fields unchanged, we consider content the same.
                    return safeEquals(oldItem.getFirstName(), newItem.getFirstName())
                            && safeEquals(oldItem.getLastName(), newItem.getLastName())
                            && safeEquals(oldItem.getSpecialtyName(), newItem.getSpecialtyName())
                            && safeEquals(oldItem.getCity(), newItem.getCity())
                            && safeEquals(oldItem.getCountry(), newItem.getCountry());
                }

                private boolean safeEquals(Object a, Object b) {
                    if (a == b) return true;
                    if (a == null || b == null) return false;
                    return a.equals(b);
                }
            };

    @NonNull
    @Override
    public DoctorViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View itemView = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_doctor_search_result, parent, false);
        return new DoctorViewHolder(itemView);
    }

    @Override
    public void onBindViewHolder(@NonNull DoctorViewHolder holder, int position) {
        DoctorSearchResult item = getItem(position);
        holder.bind(item);
    }

    class DoctorViewHolder extends RecyclerView.ViewHolder {

        private final TextView textTitle;
        private final TextView textSubtitle;

        DoctorViewHolder(@NonNull View itemView) {
            super(itemView);
            textTitle = itemView.findViewById(R.id.text_doctor_title);
            textSubtitle = itemView.findViewById(R.id.text_doctor_subtitle);

            itemView.setOnClickListener(v -> {
                int pos = getBindingAdapterPosition();
                if (pos == RecyclerView.NO_POSITION) return;
                DoctorSearchResult item = getItem(pos);
                if (item != null && clickListener != null) {
                    clickListener.onDoctorClicked(item);
                }
            });
        }

        void bind(@NonNull DoctorSearchResult doctor) {
            String displayName = doctor.getDisplayNameCompact();
            if (displayName == null) {
                displayName = "";
            }

            String specialty = doctor.getSpecialtyName();
            if (specialty == null) {
                specialty = "";
            }

            // Title: "Lastname F. Â· Specialty"
            if (!specialty.isEmpty()) {
                String formatted = itemView.getContext().getString(
                        R.string.home_patient_doctor_title_format,
                        displayName,
                        specialty
                );
                textTitle.setText(formatted);
            } else {
                textTitle.setText(displayName);
            }

            // Subtitle: city, country
            StringBuilder subtitle = new StringBuilder();
            if (doctor.getCity() != null && !doctor.getCity().trim().isEmpty()) {
                subtitle.append(doctor.getCity().trim());
            }
            if (doctor.getCountry() != null && !doctor.getCountry().trim().isEmpty()) {
                if (subtitle.length() > 0) subtitle.append(", ");
                subtitle.append(doctor.getCountry().trim());
            }

            textSubtitle.setText(subtitle.toString());
        }
    }
}


